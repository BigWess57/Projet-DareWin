{
  "stats": {
    "suites": 17,
    "tests": 66,
    "passes": 66,
    "pending": 0,
    "failures": 0,
    "start": "2025-10-28T18:04:57.908Z",
    "end": "2025-10-28T18:04:59.303Z",
    "duration": 1395,
    "testsRegistered": 66,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false
  },
  "results": [
    {
      "uuid": "4ce4ebc3-a8ca-4b83-9f7d-1cd25d657da4",
      "title": "",
      "fullFile": "",
      "file": "",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "b0ebc98a-56b1-4a63-90ed-3224020fb05a",
          "title": "tests ChallengeFactory contract",
          "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeFactoryNEW.test.js",
          "file": "/test/ChallengeFactoryNEW.test.js",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "5bf6c066-d7d0-4fcb-ab54-9cb6a3a14d75",
              "title": "First tests",
              "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeFactoryNEW.test.js",
              "file": "/test/ChallengeFactoryNEW.test.js",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"First tests\"",
                  "fullTitle": "tests ChallengeFactory contract First tests \"before each\" hook in \"First tests\"",
                  "timedOut": false,
                  "duration": 1,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "({challengeFactory, signers, token } = await loadFixture(deployedChallengeFactoryFixtureBase));\nawait challengeFactory.createChallenge(duration, maxPlayers, bid, description, 0, ethers.ZeroHash, \"ipfsCid\");",
                  "err": {},
                  "uuid": "85b66816-ede5-45d9-a9cf-328bab92abef",
                  "parentUUID": "5bf6c066-d7d0-4fcb-ab54-9cb6a3a14d75",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should just deploy the challenge factory, and create a challenge",
                  "fullTitle": "tests ChallengeFactory contract First tests should just deploy the challenge factory, and create a challenge",
                  "timedOut": false,
                  "duration": 0,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "",
                  "err": {},
                  "uuid": "3f8435f7-9bb3-43c1-a2e7-bcafdf843a12",
                  "parentUUID": "5bf6c066-d7d0-4fcb-ab54-9cb6a3a14d75",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should should not be possible to deploy with a feeReceiver address to 0",
                  "fullTitle": "tests ChallengeFactory contract First tests should should not be possible to deploy with a feeReceiver address to 0",
                  "timedOut": false,
                  "duration": 16,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const ChallengeFactory = await ethers.getContractFactory('ChallengeFactory');\nawait expect(\n    ChallengeFactory.deploy(token.target, \"0x0000000000000000000000000000000000000000\")\n).to.be.revertedWith(\"the feeReceiver cannot be address 0!\")",
                  "err": {},
                  "uuid": "1dcac717-4dff-4544-a21c-66a1fdabbbce",
                  "parentUUID": "5bf6c066-d7d0-4fcb-ab54-9cb6a3a14d75",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should emit an event on new challenge deployment",
                  "fullTitle": "tests ChallengeFactory contract First tests should emit an event on new challenge deployment",
                  "timedOut": false,
                  "duration": 7,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const filter = challengeFactory.filters.ChallengeCreated(signers[0].address);\n            const events = await challengeFactory.queryFilter(filter, -1)\n            const event = events[0]\n            expect(event.fragment.name).to.equal('ChallengeCreated')\n            const args = event.args\n            expect(args.admin).to.equal(signers[0].address)",
                  "err": {},
                  "uuid": "aebeac62-1de4-4d0d-9a1a-2b33f7a9777b",
                  "parentUUID": "5bf6c066-d7d0-4fcb-ab54-9cb6a3a14d75",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow to deploy a new challenge contract",
                  "fullTitle": "tests ChallengeFactory contract First tests should allow to deploy a new challenge contract",
                  "timedOut": false,
                  "duration": 11,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// 2. Extract the address from the event\n            const filter = challengeFactory.filters.ChallengeCreated;\n            const events = await challengeFactory.queryFilter(filter, -1)\n            const event = events[0]\n            const newContractAddress = event.args.challengeAddress;\n            // 3. Attach to the deployed challenge\n            const Challenge = await ethers.getContractFactory(\"Challenge\");\n            const challenge = Challenge.attach(newContractAddress);\n            // Verify initialisation\n            const _duration = await challenge.duration();\n            const _maxPlayers = await challenge.maxPlayers();\n            const _bid = await challenge.bid();\n            const _description = await challenge.description();\n            expect(_duration).to.equal(1000n);\n            expect(_maxPlayers).to.equal(5n);\n            expect(_bid).to.equal(bid);\n            expect(_description).to.equal(\"test\")",
                  "err": {},
                  "uuid": "950ca066-57e7-4338-a695-129add12aaa8",
                  "parentUUID": "5bf6c066-d7d0-4fcb-ab54-9cb6a3a14d75",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow to deploy a new challenge contract in GROUP mode",
                  "fullTitle": "tests ChallengeFactory contract First tests should allow to deploy a new challenge contract in GROUP mode",
                  "timedOut": false,
                  "duration": 12,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const playersAllowed = [\n                [signers[0].address],\n                [signers[1].address],\n                [signers[2].address],\n                [signers[3].address],\n                [signers[4].address]\n            ]\n            const merkleTree = StandardMerkleTree.of(playersAllowed, [\"address\"]);\n            await challengeFactory.createChallenge(1111n, maxPlayers, bid+10n, description, true, merkleTree.root, \"ipfsCid\");\n            // 2. Extract the address from the event\n            const filter = challengeFactory.filters.ChallengeCreated;\n            const events = await challengeFactory.queryFilter(filter, -1)\n            const event = events[1]\n            const newContractAddress = event.args.challengeAddress;\n            // 3. Attach to the deployed challenge\n            const Challenge = await ethers.getContractFactory(\"Challenge\");\n            const challenge = Challenge.attach(newContractAddress);\n            // Verify initialisation\n            const _duration = await challenge.duration();\n            const _maxPlayers = await challenge.maxPlayers();\n            const _bid = await challenge.bid();\n            const _description = await challenge.description();\n            expect(_duration).to.equal(1111n);\n            expect(_maxPlayers).to.equal(5n);\n            expect(_bid).to.equal(bid+10n);\n            expect(_description).to.equal(\"test\")",
                  "err": {},
                  "uuid": "82bc75aa-92bc-4ac7-9fe3-24e86b115fe1",
                  "parentUUID": "5bf6c066-d7d0-4fcb-ab54-9cb6a3a14d75",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should set the caller of the function createChallenge as owner of the challenge",
                  "fullTitle": "tests ChallengeFactory contract First tests should set the caller of the function createChallenge as owner of the challenge",
                  "timedOut": false,
                  "duration": 7,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// 2. Extract the address from the event\n            const filter = challengeFactory.filters.ChallengeCreated;\n            const events = await challengeFactory.queryFilter(filter, -1)\n            const event = events[0]\n            const newContractAddress = event.args.challengeAddress;\n            // 3. Attach to the deployed challenge\n            const Challenge = await ethers.getContractFactory(\"Challenge\");\n            const challenge = Challenge.attach(newContractAddress);\n            const owner = await challenge.owner()\n            expect(owner).to.equal(signers[0].address)",
                  "err": {},
                  "uuid": "820f372d-cdd6-47cd-a359-58b6d0d00afe",
                  "parentUUID": "5bf6c066-d7d0-4fcb-ab54-9cb6a3a14d75",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "3f8435f7-9bb3-43c1-a2e7-bcafdf843a12",
                "1dcac717-4dff-4544-a21c-66a1fdabbbce",
                "aebeac62-1de4-4d0d-9a1a-2b33f7a9777b",
                "950ca066-57e7-4338-a695-129add12aaa8",
                "82bc75aa-92bc-4ac7-9fe3-24e86b115fe1",
                "820f372d-cdd6-47cd-a359-58b6d0d00afe"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 53,
              "root": false,
              "rootEmpty": false,
              "_timeout": 40000
            },
            {
              "uuid": "bb3842f4-1df3-492e-99dc-a596f72e02f9",
              "title": "ChallengeFactory pagination",
              "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeFactoryNEW.test.js",
              "file": "/test/ChallengeFactoryNEW.test.js",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"ChallengeFactory pagination\"",
                  "fullTitle": "tests ChallengeFactory contract ChallengeFactory pagination \"before each\" hook in \"ChallengeFactory pagination\"",
                  "timedOut": false,
                  "duration": 17,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "({challengeFactory, signers, token } = await loadFixture(deployedChallengeFactoryFixtureBase));\n            // Create a bunch of challenges\n            this.numChallenges = 7;\n            this.created = [];\n            const startBlockNumber = (await ethers.provider.getBlock(\"latest\")).number + 1;\n            for (let i = 0; i < this.numChallenges; i++) {\n                const tx = await challengeFactory.createChallenge(\n                    duration,                // duration\n                    maxPlayers,                   // maxPlayers\n                    bid + BigInt(i),  // bid (just vary slightly)\n                    `desc ${i}`,         // description\n                    false,               // groupMode\n                    ethers.ZeroHash,  // merkleRoot placeholder\n                    \"ipfsCid\" // placeholder for IpfsCid  \n                );\n                const receipt = await tx.wait();\n            }\n            //then, create table once after all creations\n            const filter = challengeFactory.filters.ChallengeCreated();\n            const fromBlock = startBlockNumber; // capture before first create\n            const events = await challengeFactory.queryFilter(filter, fromBlock, \"latest\");\n            \n            for(let i = 0; i < this.numChallenges; i++) {\n                const challengeAddress = events[i].args.challengeAddress; // or evt.args[1]\n                this.created.push(challengeAddress);\n            }",
                  "err": {},
                  "uuid": "1f5df7ba-278c-4a3e-b960-cf44e42b1489",
                  "parentUUID": "bb3842f4-1df3-492e-99dc-a596f72e02f9",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should return the first batch when count < total",
                  "fullTitle": "tests ChallengeFactory contract ChallengeFactory pagination should return the first batch when count < total",
                  "timedOut": false,
                  "duration": 3,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const start = 0;\nconst count = 3;\nconst list = await challengeFactory.getChallenges(start, count);\nexpect(list.length).to.equal(count);\n// first `count` addresses should match\nfor (let i = 0; i < count; i++) {\n    expect(list[i]).to.equal(this.created[i]);\n}",
                  "err": {},
                  "uuid": "017317d3-085b-4f68-881a-377eeb3a8b12",
                  "parentUUID": "bb3842f4-1df3-492e-99dc-a596f72e02f9",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return entire list when count >= total-start",
                  "fullTitle": "tests ChallengeFactory contract ChallengeFactory pagination should return entire list when count >= total-start",
                  "timedOut": false,
                  "duration": 3,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const start = 2;\nconst count = 10;  // more than remaining\nconst list = await challengeFactory.getChallenges(start, count);\nexpect(list.length).to.equal(this.numChallenges - start);\nfor (let i = start; i < this.numChallenges; i++) {\nexpect(list[i - start]).to.equal(this.created[i]);\n}",
                  "err": {},
                  "uuid": "398ae014-d460-4d2c-9165-937f077aaee8",
                  "parentUUID": "bb3842f4-1df3-492e-99dc-a596f72e02f9",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return empty array when start >= total",
                  "fullTitle": "tests ChallengeFactory contract ChallengeFactory pagination should return empty array when start >= total",
                  "timedOut": false,
                  "duration": 1,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const start = this.numChallenges;  // equals length\nconst count = 5;\nconst list = await challengeFactory.getChallenges(start, count);\nexpect(list.length).to.equal(0);",
                  "err": {},
                  "uuid": "74eb278c-302e-440d-a875-ff6f0e1eaafe",
                  "parentUUID": "bb3842f4-1df3-492e-99dc-a596f72e02f9",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return empty if count is zero",
                  "fullTitle": "tests ChallengeFactory contract ChallengeFactory pagination should return empty if count is zero",
                  "timedOut": false,
                  "duration": 1,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const start = 1;\nconst count = 0;\nconst list = await challengeFactory.getChallenges(start, count);\nexpect(list.length).to.equal(0);",
                  "err": {},
                  "uuid": "e2e51a25-34b1-4d2f-9336-d17d49f86cd5",
                  "parentUUID": "bb3842f4-1df3-492e-99dc-a596f72e02f9",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should return last element when start = total - 1 and count >=1",
                  "fullTitle": "tests ChallengeFactory contract ChallengeFactory pagination should return last element when start = total - 1 and count >=1",
                  "timedOut": false,
                  "duration": 2,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const start = this.numChallenges - 1;\nconst count = 5;\nconst list = await challengeFactory.getChallenges(start, count);\nexpect(list.length).to.equal(1);\nexpect(list[0]).to.equal(this.created[this.numChallenges - 1]);",
                  "err": {},
                  "uuid": "4fa0a513-f1d0-4375-b1c9-6c6ab73d0914",
                  "parentUUID": "bb3842f4-1df3-492e-99dc-a596f72e02f9",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "017317d3-085b-4f68-881a-377eeb3a8b12",
                "398ae014-d460-4d2c-9165-937f077aaee8",
                "74eb278c-302e-440d-a875-ff6f0e1eaafe",
                "e2e51a25-34b1-4d2f-9336-d17d49f86cd5",
                "4fa0a513-f1d0-4375-b1c9-6c6ab73d0914"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 10,
              "root": false,
              "rootEmpty": false,
              "_timeout": 40000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 40000
        },
        {
          "uuid": "f4d2fe1b-faba-42a5-b709-95537e3194fe",
          "title": "tests Challenge contract",
          "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
          "file": "/test/ChallengeNEW.test.js",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "68481dae-b9d8-4103-8560-f8ed618d219b",
              "title": "deployment",
              "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
              "file": "/test/ChallengeNEW.test.js",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"deployment\"",
                  "fullTitle": "tests Challenge contract deployment \"before each\" hook in \"deployment\"",
                  "timedOut": false,
                  "duration": 7,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "signers = await ethers.getSigners();\n//Token deployment\nconst DareWinToken = await ethers.getContractFactory('DareWin');\ntoken = await DareWinToken.deploy(signers[0].address);\nbid = ethers.parseUnits(\"1000\", await token.decimals());",
                  "err": {},
                  "uuid": "b5432ee9-8f28-42b3-92e6-13bac4f98550",
                  "parentUUID": "68481dae-b9d8-4103-8560-f8ed618d219b",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should juste deploy the contract",
                  "fullTitle": "tests Challenge contract deployment should juste deploy the contract",
                  "timedOut": false,
                  "duration": 6,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//Challenge Deployment\nconst Challenge = await ethers.getContractFactory('Challenge'); \nawait expect(\n    Challenge.deploy(signers[0].address, token.target, duration, maxPlayers, bid, description, signers[0].address, false, ethers.ZeroHash, \"ipfsCid\")\n).to.not.be.reverted",
                  "err": {},
                  "uuid": "0480d0c0-505a-4c96-955d-c9f45952a38c",
                  "parentUUID": "68481dae-b9d8-4103-8560-f8ed618d219b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should juste deploy the contract in Group mode",
                  "fullTitle": "tests Challenge contract deployment should juste deploy the contract in Group mode",
                  "timedOut": false,
                  "duration": 5,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const playersAllowed = [\n    [signers[0].address],\n    [signers[1].address],\n    [signers[2].address],\n    [signers[3].address],\n    [signers[4].address]\n]\nmerkleTree = StandardMerkleTree.of(playersAllowed, [\"address\"]);\nconst Challenge = await ethers.getContractFactory('Challenge');\n//Challenge Deployment\nawait expect(\n    challenge = await Challenge.deploy(signers[0].address, token.target, duration, maxPlayers, bid, description, signers[0].address, true, merkleTree.root, \"ipfsCid\")\n).to.not.be.reverted",
                  "err": {},
                  "uuid": "5ba4a3ff-4db6-4b46-a494-6e617023ff4a",
                  "parentUUID": "68481dae-b9d8-4103-8560-f8ed618d219b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not be possible to deploy with a feeReceiver address to 0",
                  "fullTitle": "tests Challenge contract deployment should not be possible to deploy with a feeReceiver address to 0",
                  "timedOut": false,
                  "duration": 6,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//Challenge Deployment\nconst Challenge = await ethers.getContractFactory('Challenge'); \nawait expect(\n    Challenge.deploy(signers[0].address, token.target, duration, maxPlayers, bid, description, \"0x0000000000000000000000000000000000000000\", false, ethers.ZeroHash, \"ipfsCid\")\n).to.be.revertedWith(\"the feeReceiver cannot be address 0!\")",
                  "err": {},
                  "uuid": "8ed63288-7bf8-4dd8-b186-2166c6b3e8ba",
                  "parentUUID": "68481dae-b9d8-4103-8560-f8ed618d219b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "GROUP MODE : should not be possible to deploy if the merkle root is 0",
                  "fullTitle": "tests Challenge contract deployment GROUP MODE : should not be possible to deploy if the merkle root is 0",
                  "timedOut": false,
                  "duration": 5,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//Challenge Deployment\nconst Challenge = await ethers.getContractFactory('Challenge'); \nawait expect(\n    Challenge.deploy(signers[0].address, token.target, duration, maxPlayers, bid, description, signers[0].address, true, ethers.ZeroHash, \"ipfsCid\")\n).to.be.revertedWith(\"Merkle root required when groupMode is true\")",
                  "err": {},
                  "uuid": "96078cfb-20c9-4a8e-a7d9-440c5e885943",
                  "parentUUID": "68481dae-b9d8-4103-8560-f8ed618d219b",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "0480d0c0-505a-4c96-955d-c9f45952a38c",
                "5ba4a3ff-4db6-4b46-a494-6e617023ff4a",
                "8ed63288-7bf8-4dd8-b186-2166c6b3e8ba",
                "96078cfb-20c9-4a8e-a7d9-440c5e885943"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 22,
              "root": false,
              "rootEmpty": false,
              "_timeout": 40000
            },
            {
              "uuid": "6211499f-a13f-47a5-810b-77ef5bfb968f",
              "title": "gathering players state",
              "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
              "file": "/test/ChallengeNEW.test.js",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"gathering players state\"",
                  "fullTitle": "tests Challenge contract gathering players state \"before each\" hook in \"gathering players state\"",
                  "timedOut": false,
                  "duration": 0,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "({challenge, signers, bid, token} = await loadFixture(deployedChallengeFixtureBase));",
                  "err": {},
                  "uuid": "bdcd2c04-491c-4c88-81c5-2590d0096e9b",
                  "parentUUID": "6211499f-a13f-47a5-810b-77ef5bfb968f",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should allow a player to join, and sends the money to the challenge contract correctly",
                  "fullTitle": "tests Challenge contract gathering players state should allow a player to join, and sends the money to the challenge contract correctly",
                  "timedOut": false,
                  "duration": 7,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { v, r, s, deadline } = await GetRSVsig(signers[0], token, bid, challenge);\nexpect(\n    await token.balanceOf(challenge)\n).to.equal(0)\nawait expect(\n    challenge.joinChallenge(deadline, v, r, s, [])\n)\n.to.not.be.reverted;\n\nexpect(\n    await token.balanceOf(challenge)\n).to.equal(bid)",
                  "err": {},
                  "uuid": "b68b5ea6-3755-4f2f-bc42-2d6d27ecfb39",
                  "parentUUID": "6211499f-a13f-47a5-810b-77ef5bfb968f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "FOR LINK MODE : should not allow any more participants to join if the max is already reached",
                  "fullTitle": "tests Challenge contract gathering players state FOR LINK MODE : should not allow any more participants to join if the max is already reached",
                  "timedOut": false,
                  "duration": 23,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\nconst { v: v2, r: r2, s: s2, deadline: deadline2 } = await GetRSVsig(signers[1], token, bid, challenge);\nconst { v: v3, r: r3, s: s3, deadline: deadline3 } = await GetRSVsig(signers[2], token, bid, challenge);\nconst { v: v4, r: r4, s: s4, deadline: deadline4 } = await GetRSVsig(signers[3], token, bid, challenge);\nconst { v: v5, r: r5, s: s5, deadline: deadline5 } = await GetRSVsig(signers[4], token, bid, challenge);\nconst { v: v6, r: r6, s: s6, deadline: deadline6 } = await GetRSVsig(signers[5], token, bid, challenge);\nawait challenge.joinChallenge(deadline1, v1, r1, s1, []);\nawait challenge.connect(signers[1]).joinChallenge(deadline2, v2, r2, s2, []);\nawait challenge.connect(signers[2]).joinChallenge(deadline3, v3, r3, s3, []);\nawait challenge.connect(signers[3]).joinChallenge(deadline4, v4, r4, s4, []);\nawait challenge.connect(signers[4]).joinChallenge(deadline5, v5, r5, s5, []);\nawait expect(\n    challenge.connect(signers[5]).joinChallenge(deadline6, v6, r6, s6, [])\n).to.be.revertedWith(\"This challenge is already full\");",
                  "err": {},
                  "uuid": "26cec0d9-2934-4767-9406-8b0c97351318",
                  "parentUUID": "6211499f-a13f-47a5-810b-77ef5bfb968f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow a participant to join twice",
                  "fullTitle": "tests Challenge contract gathering players state should not allow a participant to join twice",
                  "timedOut": false,
                  "duration": 4,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\nawait challenge.joinChallenge(deadline1, v1, r1, s1, []);\nawait expect(challenge.joinChallenge(deadline1, v1, r1, s1, [])).to.be.revertedWith(\"You already joined\");",
                  "err": {},
                  "uuid": "b4251ad3-7214-4aaa-ad59-480d35ec6b7b",
                  "parentUUID": "6211499f-a13f-47a5-810b-77ef5bfb968f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow a player to withdraw from the challenge (before start), while letting the challenge start when required without issues. Money should be sent back to him",
                  "fullTitle": "tests Challenge contract gathering players state should allow a player to withdraw from the challenge (before start), while letting the challenge start when required without issues. Money should be sent back to him",
                  "timedOut": false,
                  "duration": 19,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//5 players join\nconst { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\nconst { v: v2, r: r2, s: s2, deadline: deadline2 } = await GetRSVsig(signers[1], token, bid, challenge);\nconst { v: v3, r: r3, s: s3, deadline: deadline3 } = await GetRSVsig(signers[2], token, bid, challenge);\nconst { v: v4, r: r4, s: s4, deadline: deadline4 } = await GetRSVsig(signers[3], token, bid, challenge);\nconst { v: v5, r: r5, s: s5, deadline: deadline5 } = await GetRSVsig(signers[4], token, bid, challenge);\nawait challenge.joinChallenge(deadline1, v1, r1, s1, []);\nawait challenge.connect(signers[1]).joinChallenge(deadline2, v2, r2, s2, []);\nawait challenge.connect(signers[2]).joinChallenge(deadline3, v3, r3, s3, []);\nawait challenge.connect(signers[3]).joinChallenge(deadline4, v4, r4, s4, []);\nawait challenge.connect(signers[4]).joinChallenge(deadline5, v5, r5, s5, []);\n//one player withdraws from challenge\nexpect(\n    await token.balanceOf(signers[2].address)\n).to.equal(0);\nawait challenge.connect(signers[2]).withdrawFromChallenge();\n//His balance should be 1000\nexpect(\n    await token.balanceOf(signers[2].address)\n).to.equal(bid);\n//Admin successfully starts challenge\nawait challenge.startChallenge();\nexpect(\n   await challenge.currentStatus()\n).to.equal(ChallengeStatus.OngoingChallenge);",
                  "err": {},
                  "uuid": "ff13c723-f5fb-4c45-a702-2d3ac0ecd033",
                  "parentUUID": "6211499f-a13f-47a5-810b-77ef5bfb968f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow a player to withdraw from the challenge if he hasnt joined",
                  "fullTitle": "tests Challenge contract gathering players state should not allow a player to withdraw from the challenge if he hasnt joined",
                  "timedOut": false,
                  "duration": 1,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//try to withdraw without having joined, reverts\nawait expect(\n   challenge.withdrawFromChallenge()\n).to.be.revertedWith(\"You have not joined the challenge.\");",
                  "err": {},
                  "uuid": "2d83cb60-6e37-46d6-80d4-433750e5759c",
                  "parentUUID": "6211499f-a13f-47a5-810b-77ef5bfb968f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow a player to join, and then withdraw twice",
                  "fullTitle": "tests Challenge contract gathering players state should not allow a player to join, and then withdraw twice",
                  "timedOut": false,
                  "duration": 6,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\nawait challenge.joinChallenge(deadline1, v1, r1, s1, []);\nawait challenge.withdrawFromChallenge();\n//try to withdraw without having joined, reverts\nawait expect(\n   challenge.withdrawFromChallenge()\n).to.be.revertedWith(\"You have not joined the challenge.\");",
                  "err": {},
                  "uuid": "902bbd6a-1f07-4fe0-81b1-3ce97acc1396",
                  "parentUUID": "6211499f-a13f-47a5-810b-77ef5bfb968f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow a player to join, withdraw and then join again the challenge",
                  "fullTitle": "tests Challenge contract gathering players state should allow a player to join, withdraw and then join again the challenge",
                  "timedOut": false,
                  "duration": 8,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//Needed twice, because of the nonce\nconst { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\n\nawait challenge.joinChallenge(deadline1, v1, r1, s1, []);\nawait challenge.withdrawFromChallenge();\nconst { v: v2, r: r2, s: s2, deadline: deadline2 } = await GetRSVsig(signers[0], token, bid, challenge);\nawait expect(\n   challenge.joinChallenge(deadline2, v2, r2, s2, [])\n).to.not.be.reverted",
                  "err": {},
                  "uuid": "0fed0ac8-082d-4fcb-9e39-a987b9e7fc4c",
                  "parentUUID": "6211499f-a13f-47a5-810b-77ef5bfb968f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow to start the challenge if there is less than 2 players",
                  "fullTitle": "tests Challenge contract gathering players state should not allow to start the challenge if there is less than 2 players",
                  "timedOut": false,
                  "duration": 5,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\nawait challenge.joinChallenge(deadline1, v1, r1, s1, []);\nawait expect(\n    challenge.startChallenge()\n).to.be.revertedWith(\"Not enough players to start the challenge\")",
                  "err": {},
                  "uuid": "815b5538-0955-4a82-aa4d-85c7c809fbe5",
                  "parentUUID": "6211499f-a13f-47a5-810b-77ef5bfb968f",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow the admin to go to the next state",
                  "fullTitle": "tests Challenge contract gathering players state should allow the admin to go to the next state",
                  "timedOut": false,
                  "duration": 9,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\nconst { v: v2, r: r2, s: s2, deadline: deadline2 } = await GetRSVsig(signers[1], token, bid, challenge);\nawait challenge.joinChallenge(deadline1, v1, r1, s1, []);\nawait challenge.connect(signers[1]).joinChallenge(deadline2, v2, r2, s2, []);\nawait challenge.startChallenge();\nexpect(\n   await challenge.currentStatus()\n).to.equal(ChallengeStatus.OngoingChallenge);",
                  "err": {},
                  "uuid": "38e457bb-6f8e-469b-af67-7469549abb96",
                  "parentUUID": "6211499f-a13f-47a5-810b-77ef5bfb968f",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "b68b5ea6-3755-4f2f-bc42-2d6d27ecfb39",
                "26cec0d9-2934-4767-9406-8b0c97351318",
                "b4251ad3-7214-4aaa-ad59-480d35ec6b7b",
                "ff13c723-f5fb-4c45-a702-2d3ac0ecd033",
                "2d83cb60-6e37-46d6-80d4-433750e5759c",
                "902bbd6a-1f07-4fe0-81b1-3ce97acc1396",
                "0fed0ac8-082d-4fcb-9e39-a987b9e7fc4c",
                "815b5538-0955-4a82-aa4d-85c7c809fbe5",
                "38e457bb-6f8e-469b-af67-7469549abb96"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 82,
              "root": false,
              "rootEmpty": false,
              "_timeout": 40000
            },
            {
              "uuid": "f9f9c29f-b183-4ec6-bc4e-9ae839f5ccb7",
              "title": "gathering players state (FOR GROUP MODE SPECIFIC TESTS)",
              "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
              "file": "/test/ChallengeNEW.test.js",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"gathering players state (FOR GROUP MODE SPECIFIC TESTS)\"",
                  "fullTitle": "tests Challenge contract gathering players state (FOR GROUP MODE SPECIFIC TESTS) \"before each\" hook in \"gathering players state (FOR GROUP MODE SPECIFIC TESTS)\"",
                  "timedOut": false,
                  "duration": 0,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//Deploying in group mode\n({challenge, signers, bid, token, merkleTree} = await loadFixture(groupModeFixture));",
                  "err": {},
                  "uuid": "094039ef-82fa-4b05-8638-19b1f124a8b7",
                  "parentUUID": "f9f9c29f-b183-4ec6-bc4e-9ae839f5ccb7",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "FOR GROUP MODE : should still allow players to join",
                  "fullTitle": "tests Challenge contract gathering players state (FOR GROUP MODE SPECIFIC TESTS) FOR GROUP MODE : should still allow players to join",
                  "timedOut": false,
                  "duration": 15,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\nconst { v: v2, r: r2, s: s2, deadline: deadline2 } = await GetRSVsig(signers[1], token, bid, challenge);\nconst { v: v3, r: r3, s: s3, deadline: deadline3 } = await GetRSVsig(signers[2], token, bid, challenge);\nconst { v: v4, r: r4, s: s4, deadline: deadline4 } = await GetRSVsig(signers[3], token, bid, challenge);\n//Get merkle proof for each player\nconst proof1 = merkleTree.getProof([signers[0].address]);\nconst proof2 = merkleTree.getProof([signers[1].address]);\nconst proof3 = merkleTree.getProof([signers[2].address]);\nconst proof4 = merkleTree.getProof([signers[3].address]);\n//join with proof\nawait expect(\n    challenge.connect(signers[0]).joinChallenge(deadline1, v1, r1, s1, proof1)\n).to.not.be.reverted;\nawait expect(\n    challenge.connect(signers[1]).joinChallenge(deadline2, v2, r2, s2, proof2)\n).to.not.be.reverted;\nawait expect(\n    challenge.connect(signers[2]).joinChallenge(deadline3, v3, r3, s3, proof3)\n).to.not.be.reverted;\nawait expect(\n    challenge.connect(signers[3]).joinChallenge(deadline4, v4, r4, s4, proof4)\n).to.not.be.reverted;",
                  "err": {},
                  "uuid": "7f894f44-c661-4665-be67-d0c5358b9899",
                  "parentUUID": "f9f9c29f-b183-4ec6-bc4e-9ae839f5ccb7",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "FOR GROUP MODE : should not allow a player to join if he is not among those chosen by the admin at creation",
                  "fullTitle": "tests Challenge contract gathering players state (FOR GROUP MODE SPECIFIC TESTS) FOR GROUP MODE : should not allow a player to join if he is not among those chosen by the admin at creation",
                  "timedOut": false,
                  "duration": 4,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[5], token, bid, challenge);\nconst proof1 = merkleTree.getProof([signers[0].address]);\nawait expect(\n    challenge.connect(signers[5]).joinChallenge(deadline1, v1, r1, s1, proof1)\n).to.be.revertedWith(\"You are not allowed to join this challenge.\")",
                  "err": {},
                  "uuid": "1205f2a5-cd98-4146-97f7-de3cdc51209b",
                  "parentUUID": "f9f9c29f-b183-4ec6-bc4e-9ae839f5ccb7",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "7f894f44-c661-4665-be67-d0c5358b9899",
                "1205f2a5-cd98-4146-97f7-de3cdc51209b"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 19,
              "root": false,
              "rootEmpty": false,
              "_timeout": 40000
            },
            {
              "uuid": "456d4db1-a069-48fb-8327-82e19f808abd",
              "title": "ongoing challenge state",
              "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
              "file": "/test/ChallengeNEW.test.js",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"ongoing challenge state\"",
                  "fullTitle": "tests Challenge contract ongoing challenge state \"before each\" hook in \"ongoing challenge state\"",
                  "timedOut": false,
                  "duration": 38,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "({challenge, signers} = await loadFixture(OngoingChallengeFixture));",
                  "err": {},
                  "uuid": "2e3a13a7-8466-4f40-8629-9e094c3d9207",
                  "parentUUID": "456d4db1-a069-48fb-8327-82e19f808abd",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "state should be \"OngoingChallenge\" during the challenge. ",
                  "fullTitle": "tests Challenge contract ongoing challenge state state should be \"OngoingChallenge\" during the challenge. ",
                  "timedOut": false,
                  "duration": 1,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "expect(await challenge.currentStatus()).to.equal(ChallengeStatus.OngoingChallenge);",
                  "err": {},
                  "uuid": "2d986444-ef18-4bf4-b41e-664c64125346",
                  "parentUUID": "456d4db1-a069-48fb-8327-82e19f808abd",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "2d986444-ef18-4bf4-b41e-664c64125346"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 1,
              "root": false,
              "rootEmpty": false,
              "_timeout": 40000
            },
            {
              "uuid": "3bebd658-e710-41ca-9a79-12892e1c032b",
              "title": "voting for winner state",
              "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
              "file": "/test/ChallengeNEW.test.js",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"voting for winner state\"",
                  "fullTitle": "tests Challenge contract voting for winner state \"before each\" hook in \"voting for winner state\"",
                  "timedOut": false,
                  "duration": 0,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "({challenge, signers} = await loadFixture(VotingForWinnerFixture));",
                  "err": {},
                  "uuid": "b608b010-7d1d-4a93-b1d7-1f0fed439abe",
                  "parentUUID": "3bebd658-e710-41ca-9a79-12892e1c032b",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should allow a player to vote (for another player).",
                  "fullTitle": "tests Challenge contract voting for winner state should allow a player to vote (for another player).",
                  "timedOut": false,
                  "duration": 1,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await expect(\n    challenge.voteForWinner(signers[1].address)\n).to.not.be.reverted;",
                  "err": {},
                  "uuid": "31c7d1eb-51ad-4e41-a677-62128e2ec8e7",
                  "parentUUID": "3bebd658-e710-41ca-9a79-12892e1c032b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow a non player to vote",
                  "fullTitle": "tests Challenge contract voting for winner state should not allow a non player to vote",
                  "timedOut": false,
                  "duration": 1,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await expect(\n   challenge.connect(signers[5]).voteForWinner(signers[1].address)\n).to.be.revertedWith(\"You are not a player. You cannot vote for winner.\");",
                  "err": {},
                  "uuid": "8b1df22d-c858-4f9e-a7e3-271b58df67cc",
                  "parentUUID": "3bebd658-e710-41ca-9a79-12892e1c032b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow a player to vote twice",
                  "fullTitle": "tests Challenge contract voting for winner state should not allow a player to vote twice",
                  "timedOut": false,
                  "duration": 2,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await challenge.voteForWinner(signers[1].address);\nawait expect(\n   challenge.voteForWinner(signers[1].address)\n).to.be.revertedWith(\"You have already voted.\");",
                  "err": {},
                  "uuid": "0b05ee20-91f2-4787-977d-b0ed9a7f4574",
                  "parentUUID": "3bebd658-e710-41ca-9a79-12892e1c032b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow to go to next state (ChallengeWon) if everyone has not voted (and minimum delay hasn't passed)",
                  "fullTitle": "tests Challenge contract voting for winner state should not allow to go to next state (ChallengeWon) if everyone has not voted (and minimum delay hasn't passed)",
                  "timedOut": false,
                  "duration": 3,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await challenge.voteForWinner(signers[1].address)\nawait challenge.connect(signers[1]).voteForWinner(signers[1].address)\nawait expect(\n   challenge.endWinnerVote()\n).to.be.revertedWith(\"Not all player have voted for a winner yet (and minimum delay has not passed)\");",
                  "err": {},
                  "uuid": "8364951a-5533-4c15-83af-b26c8bc67c48",
                  "parentUUID": "3bebd658-e710-41ca-9a79-12892e1c032b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow ANYONE to go to next state (ChallengeWon) if everyone has not voted but minimum delay has passed",
                  "fullTitle": "tests Challenge contract voting for winner state should allow ANYONE to go to next state (ChallengeWon) if everyone has not voted but minimum delay has passed",
                  "timedOut": false,
                  "duration": 4,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await challenge.voteForWinner(signers[1].address)\nawait challenge.connect(signers[1]).voteForWinner(signers[1].address)\n//Pass enough time\nawait time.increase(votingDelay);\nawait expect(\n   challenge.connect(signers[2]).endWinnerVote()\n).not.to.be.reverted;",
                  "err": {},
                  "uuid": "cec527ba-4c00-48bc-a836-dacde6b8bc25",
                  "parentUUID": "3bebd658-e710-41ca-9a79-12892e1c032b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should allow ANYONE to go to next state (ChallengeWon) when everyone voted",
                  "fullTitle": "tests Challenge contract voting for winner state should allow ANYONE to go to next state (ChallengeWon) when everyone voted",
                  "timedOut": false,
                  "duration": 8,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await challenge.voteForWinner(signers[1].address)\nawait challenge.connect(signers[1]).voteForWinner(signers[1].address) \nawait challenge.connect(signers[2]).voteForWinner(signers[2].address) \nawait challenge.connect(signers[3]).voteForWinner(signers[1].address) \nawait challenge.connect(signers[4]).voteForWinner(signers[2].address) \n//Any player can end vote, because everyone has voted\nawait challenge.connect(signers[1]).endWinnerVote();\nexpect(await challenge.currentStatus()).to.equal(ChallengeStatus.ChallengeWon);",
                  "err": {},
                  "uuid": "b9269a3d-34de-405b-8a79-5d38abfd76e9",
                  "parentUUID": "3bebd658-e710-41ca-9a79-12892e1c032b",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should not allow ANYONE to go to next state (ChallengeWon) if no one has voted (even if time has passed)",
                  "fullTitle": "tests Challenge contract voting for winner state should not allow ANYONE to go to next state (ChallengeWon) if no one has voted (even if time has passed)",
                  "timedOut": false,
                  "duration": 2,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//Pass enough time\n            await time.increase(votingDelay);\n            //Any player can end vote, because everyone has voted\n            await expect(challenge.connect(signers[1]).endWinnerVote()).to.be.revertedWith('Not allowed in this state');",
                  "err": {},
                  "uuid": "775ee475-b673-45fb-b068-ddf44846728d",
                  "parentUUID": "3bebd658-e710-41ca-9a79-12892e1c032b",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "31c7d1eb-51ad-4e41-a677-62128e2ec8e7",
                "8b1df22d-c858-4f9e-a7e3-271b58df67cc",
                "0b05ee20-91f2-4787-977d-b0ed9a7f4574",
                "8364951a-5533-4c15-83af-b26c8bc67c48",
                "cec527ba-4c00-48bc-a836-dacde6b8bc25",
                "b9269a3d-34de-405b-8a79-5d38abfd76e9",
                "775ee475-b673-45fb-b068-ddf44846728d"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 21,
              "root": false,
              "rootEmpty": false,
              "_timeout": 40000
            },
            {
              "uuid": "155899a5-a95d-48a4-8ef5-b0cad6172043",
              "title": "challenge won state",
              "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
              "file": "/test/ChallengeNEW.test.js",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"challenge won state\"",
                  "fullTitle": "tests Challenge contract challenge won state \"before each\" hook in \"challenge won state\"",
                  "timedOut": false,
                  "duration": 1,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "({challenge, signers, bid, token} = await loadFixture(VotingForWinnerFixture));",
                  "err": {},
                  "uuid": "dc60d155-8b0c-4d07-993f-3450eca05fe0",
                  "parentUUID": "155899a5-a95d-48a4-8ef5-b0cad6172043",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "winner should be able to retrieve prize when endWinnerVote() is triggered",
                  "fullTitle": "tests Challenge contract challenge won state winner should be able to retrieve prize when endWinnerVote() is triggered",
                  "timedOut": false,
                  "duration": 8,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//Players voting\nawait challenge.voteForWinner(signers[1].address)\nawait challenge.connect(signers[1]).voteForWinner(signers[2].address) \nawait challenge.connect(signers[2]).voteForWinner(signers[2].address) \nawait challenge.connect(signers[3]).voteForWinner(signers[1].address) \nawait challenge.connect(signers[4]).voteForWinner(signers[2].address) \n//Check balance before\nconst balanceBefore = await token.balanceOf(signers[2].address);\n//End vote\nawait challenge.endWinnerVote();\nawait challenge.connect(signers[2]).withdrawPrize();\n//Check balance after\nconst balanceAfter = await token.balanceOf(signers[2].address);\nconst diff = balanceAfter - balanceBefore;\nconst expectedDiff = bid*5n - 5n*bid*bronze/100n;\n//Difference should be equal to cash prize won\nexpect(diff).to.equal(expectedDiff); // substract fees too",
                  "err": {},
                  "uuid": "d2b5d900-9af8-4152-819e-780581cf70a7",
                  "parentUUID": "155899a5-a95d-48a4-8ef5-b0cad6172043",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "winner should NOT be able to retrieve prize multiple times",
                  "fullTitle": "tests Challenge contract challenge won state winner should NOT be able to retrieve prize multiple times",
                  "timedOut": false,
                  "duration": 9,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//Players voting\nawait challenge.voteForWinner(signers[1].address)\nawait challenge.connect(signers[1]).voteForWinner(signers[2].address) \nawait challenge.connect(signers[2]).voteForWinner(signers[2].address) \nawait challenge.connect(signers[3]).voteForWinner(signers[1].address) \nawait challenge.connect(signers[4]).voteForWinner(signers[2].address) \n//End vote\nawait challenge.endWinnerVote();\nawait challenge.connect(signers[2]).withdrawPrize();\nawait expect(\n    challenge.connect(signers[2]).withdrawPrize()\n).to.be.revertedWith(\"You have already withdrawn your prize\");",
                  "err": {},
                  "uuid": "d82d227b-b58d-420c-a3cc-3760841de925",
                  "parentUUID": "155899a5-a95d-48a4-8ef5-b0cad6172043",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "When there is a tie, should allow both winners to receive prize",
                  "fullTitle": "tests Challenge contract challenge won state When there is a tie, should allow both winners to receive prize",
                  "timedOut": false,
                  "duration": 10,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//Players voting\nawait challenge.voteForWinner(signers[2].address)\nawait challenge.connect(signers[1]).voteForWinner(signers[1].address)\nawait challenge.connect(signers[2]).voteForWinner(signers[2].address)\nawait challenge.connect(signers[3]).voteForWinner(signers[1].address)\nawait challenge.connect(signers[4]).voteForWinner(signers[4].address)\n//Check balance before for both winners\nconst balanceBefore1 = await token.balanceOf(signers[1].address);\nconst balanceBefore2 = await token.balanceOf(signers[2].address);\n//End vote\nawait challenge.endWinnerVote();\nawait challenge.connect(signers[1]).withdrawPrize();\n//Check balance after (winner1)\nconst balanceAfter1 = await token.balanceOf(signers[1].address);\nconst diff1 = balanceAfter1 - balanceBefore1;\nconst expectedDiff1 = bid*5n/2n - bid*5n/2n*gold/100n;\nexpect(\n    diff1\n).to.equal(expectedDiff1);\nawait challenge.connect(signers[2]).withdrawPrize();\n//Check balance after (winner2)\nconst balanceAfter2 = await token.balanceOf(signers[2].address);\nconst diff2 = balanceAfter2 - balanceBefore2;\nconst expectedDiff2 = bid*5n/2n - bid*5n/2n*bronze/100n;\nexpect(\n    diff2\n).to.equal(expectedDiff2); //substract fees too",
                  "err": {},
                  "uuid": "75238517-9635-40ff-9b92-058b8d1e04b8",
                  "parentUUID": "155899a5-a95d-48a4-8ef5-b0cad6172043",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "if more tokens (signers[1] gold tier here), winner should receive more tokens",
                  "fullTitle": "tests Challenge contract challenge won state if more tokens (signers[1] gold tier here), winner should receive more tokens",
                  "timedOut": false,
                  "duration": 8,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//Players voting\nawait challenge.voteForWinner(signers[1].address)\nawait challenge.connect(signers[1]).voteForWinner(signers[1].address) \nawait challenge.connect(signers[2]).voteForWinner(signers[1].address) \nawait challenge.connect(signers[3]).voteForWinner(signers[0].address) \nawait challenge.connect(signers[4]).voteForWinner(signers[2].address) \n//Check balance before\nconst balanceBefore = await token.balanceOf(signers[1].address);\n//End vote\nawait challenge.endWinnerVote();\nawait challenge.connect(signers[1]).withdrawPrize();\n//Check balance after\nconst balanceAfter = await token.balanceOf(signers[1].address);\nconst diff = balanceAfter - balanceBefore;\nconst expectedDiff = bid*5n - 5n*bid*gold/100n;\n//Difference should be equal to cash prize won\nexpect(diff).to.equal(expectedDiff); // substract fees too",
                  "err": {},
                  "uuid": "54c7a5ff-f3c4-4370-bfcb-183987cb45c2",
                  "parentUUID": "155899a5-a95d-48a4-8ef5-b0cad6172043",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "fee receiver should receive half of the fees (the rest is burnt)",
                  "fullTitle": "tests Challenge contract challenge won state fee receiver should receive half of the fees (the rest is burnt)",
                  "timedOut": false,
                  "duration": 9,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//Players voting\nawait challenge.voteForWinner(signers[2].address)\nawait challenge.connect(signers[1]).voteForWinner(signers[2].address)\nawait challenge.connect(signers[2]).voteForWinner(signers[2].address)\nawait challenge.connect(signers[3]).voteForWinner(signers[1].address)\nawait challenge.connect(signers[4]).voteForWinner(signers[4].address)\nconst balanceBefore = await token.balanceOf(signers[0].address);\n//End vote\nawait challenge.endWinnerVote();\nawait challenge.connect(signers[2]).withdrawPrize();\nconst balanceAfter = await token.balanceOf(signers[0].address);\nconst diff = balanceAfter - balanceBefore;\nconst expectedFeesReceived = 5n*bid/2n*bronze/100n;\n\nexpect(\n    diff\n).to.equal(expectedFeesReceived);",
                  "err": {},
                  "uuid": "54643a1c-b594-43f6-b2fa-a00780296134",
                  "parentUUID": "155899a5-a95d-48a4-8ef5-b0cad6172043",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "half of the fees should have been burnt",
                  "fullTitle": "tests Challenge contract challenge won state half of the fees should have been burnt",
                  "timedOut": false,
                  "duration": 9,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "//Players voting\nawait challenge.voteForWinner(signers[0].address)\nawait challenge.connect(signers[1]).voteForWinner(signers[0].address)\nawait challenge.connect(signers[2]).voteForWinner(signers[2].address)\nawait challenge.connect(signers[3]).voteForWinner(signers[1].address)\nawait challenge.connect(signers[4]).voteForWinner(signers[4].address)\nconst initialTotalSupply = await token.totalSupply();\n//End vote\nawait challenge.endWinnerVote();\nawait challenge.connect(signers[0]).withdrawPrize();\nconst finalTotalSupply = await token.totalSupply();\nconst diff = initialTotalSupply - finalTotalSupply;\nconst expectedBurntAmount = bid*5n/2n*platinum/100n;\n\nexpect(\n    diff\n).to.equal(expectedBurntAmount);",
                  "err": {},
                  "uuid": "a4b1025f-63f0-4cc8-b224-7306b7df8dc6",
                  "parentUUID": "155899a5-a95d-48a4-8ef5-b0cad6172043",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "d2b5d900-9af8-4152-819e-780581cf70a7",
                "d82d227b-b58d-420c-a3cc-3760841de925",
                "75238517-9635-40ff-9b92-058b8d1e04b8",
                "54c7a5ff-f3c4-4370-bfcb-183987cb45c2",
                "54643a1c-b594-43f6-b2fa-a00780296134",
                "a4b1025f-63f0-4cc8-b224-7306b7df8dc6"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 53,
              "root": false,
              "rootEmpty": false,
              "_timeout": 40000
            },
            {
              "uuid": "3b8c59c4-834c-46b5-9775-e8f8c042162d",
              "title": "Owner functions",
              "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
              "file": "/test/ChallengeNEW.test.js",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should not allow not admin player to go to OngoingChallenge state",
                  "fullTitle": "tests Challenge contract Owner functions should not allow not admin player to go to OngoingChallenge state",
                  "timedOut": false,
                  "duration": 3,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const {challenge, signers} = await loadFixture(deployedChallengeFixtureBase);\nawait expect(\n   challenge.connect(signers[1]).startChallenge()\n).to.be.revertedWithCustomError(challenge, \"OwnableUnauthorizedAccount\").withArgs(signers[1].address);",
                  "err": {},
                  "uuid": "6c05c27e-f586-4aa0-9129-7018726f7cbc",
                  "parentUUID": "3b8c59c4-834c-46b5-9775-e8f8c042162d",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "6c05c27e-f586-4aa0-9129-7018726f7cbc"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 3,
              "root": false,
              "rootEmpty": false,
              "_timeout": 40000
            },
            {
              "uuid": "b02c5331-11a5-429f-a7be-0d84dd9117e6",
              "title": "State functions availability",
              "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
              "file": "/test/ChallengeNEW.test.js",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [],
              "suites": [
                {
                  "uuid": "e1420ba6-c219-4a28-b457-e9b2a1f3cf44",
                  "title": "state GatheringPlayers",
                  "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
                  "file": "/test/ChallengeNEW.test.js",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"state GatheringPlayers\"",
                      "fullTitle": "tests Challenge contract State functions availability state GatheringPlayers \"before each\" hook in \"state GatheringPlayers\"",
                      "timedOut": false,
                      "duration": 0,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "({challenge, signers} = await loadFixture(deployedChallengeFixtureBase));",
                      "err": {},
                      "uuid": "2c91670d-750b-4ce3-8e96-714b402310b2",
                      "parentUUID": "e1420ba6-c219-4a28-b457-e9b2a1f3cf44",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should not allow voteForWinner() in GatheringPlayers state",
                      "fullTitle": "tests Challenge contract State functions availability state GatheringPlayers should not allow voteForWinner() in GatheringPlayers state",
                      "timedOut": false,
                      "duration": 2,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.voteForWinner(signers[1].address)\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "09822054-fee6-42b5-a4fc-c153ea99bd98",
                      "parentUUID": "e1420ba6-c219-4a28-b457-e9b2a1f3cf44",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow endWinnerVote() in GatheringPlayers state",
                      "fullTitle": "tests Challenge contract State functions availability state GatheringPlayers should not allow endWinnerVote() in GatheringPlayers state",
                      "timedOut": false,
                      "duration": 2,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.endWinnerVote()\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "62068f98-8622-4021-8caa-53731d3972ed",
                      "parentUUID": "e1420ba6-c219-4a28-b457-e9b2a1f3cf44",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow withdrawPrize() in GatheringPlayers state",
                      "fullTitle": "tests Challenge contract State functions availability state GatheringPlayers should not allow withdrawPrize() in GatheringPlayers state",
                      "timedOut": false,
                      "duration": 1,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.withdrawPrize()\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "08209d41-2514-49d8-bf85-5942b8198668",
                      "parentUUID": "e1420ba6-c219-4a28-b457-e9b2a1f3cf44",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "09822054-fee6-42b5-a4fc-c153ea99bd98",
                    "62068f98-8622-4021-8caa-53731d3972ed",
                    "08209d41-2514-49d8-bf85-5942b8198668"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 5,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 40000
                },
                {
                  "uuid": "18a6312d-ca57-462f-9b3f-d3d1ae94e18e",
                  "title": "state OngoingChallenge",
                  "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
                  "file": "/test/ChallengeNEW.test.js",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"state OngoingChallenge\"",
                      "fullTitle": "tests Challenge contract State functions availability state OngoingChallenge \"before each\" hook in \"state OngoingChallenge\"",
                      "timedOut": false,
                      "duration": 0,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "({challenge, signers, bid, token} = await loadFixture(OngoingChallengeFixture));",
                      "err": {},
                      "uuid": "a0e5a692-fba3-4e75-af0c-0ff73fc64c2f",
                      "parentUUID": "18a6312d-ca57-462f-9b3f-d3d1ae94e18e",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should not allow joinChallenge() in OngoingChallenge state",
                      "fullTitle": "tests Challenge contract State functions availability state OngoingChallenge should not allow joinChallenge() in OngoingChallenge state",
                      "timedOut": false,
                      "duration": 3,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\nawait expect(\n    challenge.joinChallenge(deadline1, v1, r1, s1, [])\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "efe8f9ab-78e2-4d31-9bb2-126719c42af1",
                      "parentUUID": "18a6312d-ca57-462f-9b3f-d3d1ae94e18e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow withdrawFromChallenge() in OngoingChallenge state",
                      "fullTitle": "tests Challenge contract State functions availability state OngoingChallenge should not allow withdrawFromChallenge() in OngoingChallenge state",
                      "timedOut": false,
                      "duration": 1,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.withdrawFromChallenge()\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "c5627bef-6d6f-4fc4-96c7-2ba9a18c9d28",
                      "parentUUID": "18a6312d-ca57-462f-9b3f-d3d1ae94e18e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow startChallenge() in OngoingChallenge state",
                      "fullTitle": "tests Challenge contract State functions availability state OngoingChallenge should not allow startChallenge() in OngoingChallenge state",
                      "timedOut": false,
                      "duration": 1,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.startChallenge()\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "2592b67c-5cda-40be-9682-ed0b74eb662d",
                      "parentUUID": "18a6312d-ca57-462f-9b3f-d3d1ae94e18e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow voteForWinner() in OngoingChallenge state (if the challenge is not over)",
                      "fullTitle": "tests Challenge contract State functions availability state OngoingChallenge should not allow voteForWinner() in OngoingChallenge state (if the challenge is not over)",
                      "timedOut": false,
                      "duration": 1,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.voteForWinner(signers[1].address)\n).to.be.revertedWith(\"You are not allowed to vote now\");",
                      "err": {},
                      "uuid": "9c401f6e-6e2d-459f-a6fe-3e6a0ed4f670",
                      "parentUUID": "18a6312d-ca57-462f-9b3f-d3d1ae94e18e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should allow voteForWinner() in OngoingChallenge state (if the challenge is over). state should become \"VotingForWinner\" after first player votes at the end of the challenge. ",
                      "fullTitle": "tests Challenge contract State functions availability state OngoingChallenge should allow voteForWinner() in OngoingChallenge state (if the challenge is over). state should become \"VotingForWinner\" after first player votes at the end of the challenge. ",
                      "timedOut": false,
                      "duration": 3,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "expect(await challenge.currentStatus()).to.equal(ChallengeStatus.OngoingChallenge);\n//wait for challenge to end\nawait time.increase(duration);\n\n//should be allowed\nawait expect(\n    challenge.voteForWinner(signers[1].address)\n).to.not.be.reverted;\n//State should have changed\nexpect(await challenge.currentStatus()).to.equal(ChallengeStatus.VotingForWinner);",
                      "err": {},
                      "uuid": "cbcb1488-2607-4435-8388-3d30d9de53bf",
                      "parentUUID": "18a6312d-ca57-462f-9b3f-d3d1ae94e18e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow endWinnerVote() in OngoingChallenge state",
                      "fullTitle": "tests Challenge contract State functions availability state OngoingChallenge should not allow endWinnerVote() in OngoingChallenge state",
                      "timedOut": false,
                      "duration": 1,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.endWinnerVote()\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "f5d5ec4b-68e6-48ae-96cb-16cea20710ee",
                      "parentUUID": "18a6312d-ca57-462f-9b3f-d3d1ae94e18e",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow withdrawPrize() in OnGoingChallenge state",
                      "fullTitle": "tests Challenge contract State functions availability state OngoingChallenge should not allow withdrawPrize() in OnGoingChallenge state",
                      "timedOut": false,
                      "duration": 2,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.withdrawPrize()\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "c66fd472-5386-4f37-8d82-08e417463f13",
                      "parentUUID": "18a6312d-ca57-462f-9b3f-d3d1ae94e18e",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "efe8f9ab-78e2-4d31-9bb2-126719c42af1",
                    "c5627bef-6d6f-4fc4-96c7-2ba9a18c9d28",
                    "2592b67c-5cda-40be-9682-ed0b74eb662d",
                    "9c401f6e-6e2d-459f-a6fe-3e6a0ed4f670",
                    "cbcb1488-2607-4435-8388-3d30d9de53bf",
                    "f5d5ec4b-68e6-48ae-96cb-16cea20710ee",
                    "c66fd472-5386-4f37-8d82-08e417463f13"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 12,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 40000
                },
                {
                  "uuid": "8a88ac74-8ace-4858-8b6b-49e7578338d3",
                  "title": "state VotingForWinner",
                  "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
                  "file": "/test/ChallengeNEW.test.js",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"state VotingForWinner\"",
                      "fullTitle": "tests Challenge contract State functions availability state VotingForWinner \"before each\" hook in \"state VotingForWinner\"",
                      "timedOut": false,
                      "duration": 1,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "({challenge, signers, bid, token} = await loadFixture(VotingForWinnerFixture));",
                      "err": {},
                      "uuid": "9f53b2b1-0f6e-49df-a678-1648d101f9fd",
                      "parentUUID": "8a88ac74-8ace-4858-8b6b-49e7578338d3",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should not allow joinChallenge() in VotingForWinner state",
                      "fullTitle": "tests Challenge contract State functions availability state VotingForWinner should not allow joinChallenge() in VotingForWinner state",
                      "timedOut": false,
                      "duration": 4,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\nawait expect(\n    challenge.joinChallenge(deadline1, v1, r1, s1, [])\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "db192dc6-e418-40b7-a41c-6fffb336f92b",
                      "parentUUID": "8a88ac74-8ace-4858-8b6b-49e7578338d3",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow withdrawFromChallenge() in OngoingChallenge state",
                      "fullTitle": "tests Challenge contract State functions availability state VotingForWinner should not allow withdrawFromChallenge() in OngoingChallenge state",
                      "timedOut": false,
                      "duration": 1,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.withdrawFromChallenge()\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "25069bb1-8180-42cd-be32-a2c4200fee01",
                      "parentUUID": "8a88ac74-8ace-4858-8b6b-49e7578338d3",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow startChallenge() in VotingForWinner state",
                      "fullTitle": "tests Challenge contract State functions availability state VotingForWinner should not allow startChallenge() in VotingForWinner state",
                      "timedOut": false,
                      "duration": 1,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.startChallenge()\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "9f5c2bed-b4f6-42e9-b7d4-079c91aae303",
                      "parentUUID": "8a88ac74-8ace-4858-8b6b-49e7578338d3",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow withdrawPrize() in VotingForWinner state",
                      "fullTitle": "tests Challenge contract State functions availability state VotingForWinner should not allow withdrawPrize() in VotingForWinner state",
                      "timedOut": false,
                      "duration": 1,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.withdrawPrize()\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "f0f16bf4-78d1-4474-8181-53cf22d8a50b",
                      "parentUUID": "8a88ac74-8ace-4858-8b6b-49e7578338d3",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "db192dc6-e418-40b7-a41c-6fffb336f92b",
                    "25069bb1-8180-42cd-be32-a2c4200fee01",
                    "9f5c2bed-b4f6-42e9-b7d4-079c91aae303",
                    "f0f16bf4-78d1-4474-8181-53cf22d8a50b"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 7,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 40000
                },
                {
                  "uuid": "0c7a796c-72de-4db8-bd79-85ace83c46f3",
                  "title": "state ChallengeWon",
                  "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
                  "file": "/test/ChallengeNEW.test.js",
                  "beforeHooks": [
                    {
                      "title": "\"before each\" hook in \"state ChallengeWon\"",
                      "fullTitle": "tests Challenge contract State functions availability state ChallengeWon \"before each\" hook in \"state ChallengeWon\"",
                      "timedOut": false,
                      "duration": 2,
                      "state": null,
                      "speed": null,
                      "pass": false,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "({challenge, signers, bid, token} = await loadFixture(EndingVoteFixture));\nawait challenge.endWinnerVote();",
                      "err": {},
                      "uuid": "204a0383-6c34-4755-af2f-b04746a270dc",
                      "parentUUID": "0c7a796c-72de-4db8-bd79-85ace83c46f3",
                      "isHook": true,
                      "skipped": false
                    }
                  ],
                  "afterHooks": [],
                  "tests": [
                    {
                      "title": "should not allow joinChallenge() in ChallengeWon state",
                      "fullTitle": "tests Challenge contract State functions availability state ChallengeWon should not allow joinChallenge() in ChallengeWon state",
                      "timedOut": false,
                      "duration": 4,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "const { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\nawait expect(\n    challenge.joinChallenge(deadline1, v1, r1, s1, [])\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "a42d8800-6fbf-4dfe-b199-957c20cbbc50",
                      "parentUUID": "0c7a796c-72de-4db8-bd79-85ace83c46f3",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow withdrawFromChallenge() in OngoingChallenge state",
                      "fullTitle": "tests Challenge contract State functions availability state ChallengeWon should not allow withdrawFromChallenge() in OngoingChallenge state",
                      "timedOut": false,
                      "duration": 1,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.withdrawFromChallenge()\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "706efe1b-be25-4998-969e-b4fc4a2b29f2",
                      "parentUUID": "0c7a796c-72de-4db8-bd79-85ace83c46f3",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow startChallenge() in ChallengeWon state",
                      "fullTitle": "tests Challenge contract State functions availability state ChallengeWon should not allow startChallenge() in ChallengeWon state",
                      "timedOut": false,
                      "duration": 1,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.startChallenge()\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "86de490e-f922-4aa9-96e9-8f821be61305",
                      "parentUUID": "0c7a796c-72de-4db8-bd79-85ace83c46f3",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow voteForWinner() in ChallengeWon state",
                      "fullTitle": "tests Challenge contract State functions availability state ChallengeWon should not allow voteForWinner() in ChallengeWon state",
                      "timedOut": false,
                      "duration": 1,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.voteForWinner(signers[1].address)\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "7461ada9-ce75-4509-bbea-b6544b14c6b5",
                      "parentUUID": "0c7a796c-72de-4db8-bd79-85ace83c46f3",
                      "isHook": false,
                      "skipped": false
                    },
                    {
                      "title": "should not allow endWinnerVote() in ChallengeWon state",
                      "fullTitle": "tests Challenge contract State functions availability state ChallengeWon should not allow endWinnerVote() in ChallengeWon state",
                      "timedOut": false,
                      "duration": 1,
                      "state": "passed",
                      "speed": "fast",
                      "pass": true,
                      "fail": false,
                      "pending": false,
                      "context": null,
                      "code": "await expect(\n    challenge.endWinnerVote()\n).to.be.revertedWith(\"Not allowed in this state\");",
                      "err": {},
                      "uuid": "7506eebc-b760-4d16-af60-0679ed9130b3",
                      "parentUUID": "0c7a796c-72de-4db8-bd79-85ace83c46f3",
                      "isHook": false,
                      "skipped": false
                    }
                  ],
                  "suites": [],
                  "passes": [
                    "a42d8800-6fbf-4dfe-b199-957c20cbbc50",
                    "706efe1b-be25-4998-969e-b4fc4a2b29f2",
                    "86de490e-f922-4aa9-96e9-8f821be61305",
                    "7461ada9-ce75-4509-bbea-b6544b14c6b5",
                    "7506eebc-b760-4d16-af60-0679ed9130b3"
                  ],
                  "failures": [],
                  "pending": [],
                  "skipped": [],
                  "duration": 8,
                  "root": false,
                  "rootEmpty": false,
                  "_timeout": 40000
                }
              ],
              "passes": [],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 0,
              "root": false,
              "rootEmpty": false,
              "_timeout": 40000
            },
            {
              "uuid": "e2db7113-c109-4a23-801e-f6207f18c9bf",
              "title": "Events",
              "fullFile": "/home/ibuntu/BlockchainDev/Alyra/MyTests/PROJET_FINAL/backend/test/ChallengeNEW.test.js",
              "file": "/test/ChallengeNEW.test.js",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "should emit an event when a Player Joined",
                  "fullTitle": "tests Challenge contract Events should emit an event when a Player Joined",
                  "timedOut": false,
                  "duration": 6,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const {challenge, signers, bid, token} = await loadFixture(deployedChallengeFixtureBase)\nconst { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\nawait expect(challenge.joinChallenge(deadline1, v1, r1, s1, []))\n    .to.emit(challenge, \"PlayerJoined\")\n    .withArgs(signers[0].address);",
                  "err": {},
                  "uuid": "66fa5cd6-67f8-45d9-98be-c4d17ea1e3fe",
                  "parentUUID": "e2db7113-c109-4a23-801e-f6207f18c9bf",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should emit an event when a Player Withdraws from challenge",
                  "fullTitle": "tests Challenge contract Events should emit an event when a Player Withdraws from challenge",
                  "timedOut": false,
                  "duration": 6,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const {challenge, signers, bid, token} = await loadFixture(deployedChallengeFixtureBase)\nconst { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\nawait challenge.joinChallenge(deadline1, v1, r1, s1, []);\nawait expect(challenge.withdrawFromChallenge())\n    .to.emit(challenge, \"PlayerWithdrawn\")\n    .withArgs(signers[0].address);",
                  "err": {},
                  "uuid": "2e06c8f4-ccd7-4904-a55c-73fa5b2e3dad",
                  "parentUUID": "e2db7113-c109-4a23-801e-f6207f18c9bf",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should emit an event when ChallengeStarted",
                  "fullTitle": "tests Challenge contract Events should emit an event when ChallengeStarted",
                  "timedOut": false,
                  "duration": 9,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const {challenge, signers, bid, token} = await loadFixture(deployedChallengeFixtureBase)\nconst { v: v1, r: r1, s: s1, deadline: deadline1 } = await GetRSVsig(signers[0], token, bid, challenge);\nconst { v: v2, r: r2, s: s2, deadline: deadline2 } = await GetRSVsig(signers[1], token, bid, challenge);\nawait challenge.joinChallenge(deadline1, v1, r1, s1, []);\nawait challenge.connect(signers[1]).joinChallenge(deadline2, v2, r2, s2, []);\nawait expect(challenge.startChallenge())\n    .to.emit(challenge, \"ChallengeStarted\")",
                  "err": {},
                  "uuid": "5870bec0-be19-44ff-a6b5-c83efeccfe4e",
                  "parentUUID": "e2db7113-c109-4a23-801e-f6207f18c9bf",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should emit an event when ChallengeEnded ",
                  "fullTitle": "tests Challenge contract Events should emit an event when ChallengeEnded ",
                  "timedOut": false,
                  "duration": 42,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const {challenge, signers} = await loadFixture(OngoingChallengeFixture)\n//Pass enough time\nawait time.increase(duration)\nawait expect(challenge.voteForWinner(signers[1].address))\n    .to.emit(challenge, \"ChallengeEnded\")",
                  "err": {},
                  "uuid": "663864b4-76e9-4bc0-84de-dcffd0b87071",
                  "parentUUID": "e2db7113-c109-4a23-801e-f6207f18c9bf",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should emit an event when PlayerVoted",
                  "fullTitle": "tests Challenge contract Events should emit an event when PlayerVoted",
                  "timedOut": false,
                  "duration": 49,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const {challenge, signers} = await loadFixture(VotingForWinnerFixture)\nawait expect(challenge.voteForWinner(signers[1].address))\n    .to.emit(challenge, \"PlayerVoted\")\n    .withArgs(signers[0].address, signers[1].address)",
                  "err": {},
                  "uuid": "e1b3bf75-e879-4ba2-a631-492c73394b22",
                  "parentUUID": "e2db7113-c109-4a23-801e-f6207f18c9bf",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "should emit an event when a prize is sent",
                  "fullTitle": "tests Challenge contract Events should emit an event when a prize is sent",
                  "timedOut": false,
                  "duration": 50,
                  "state": "passed",
                  "speed": "medium",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const {challenge, signers, bid} = await loadFixture(EndingVoteFixture)\nawait challenge.endWinnerVote()\nconst expectedPrize = bid*5n - 5n*bid*BigInt(gold)/100n;\nawait expect(\n    await challenge.connect(signers[1]).withdrawPrize()\n).to.emit(challenge, \"PrizeWithdrawn\")\n    .withArgs(signers[1].address, expectedPrize)",
                  "err": {},
                  "uuid": "d64cdf2b-0b7b-4d20-90b7-9aaa539cf149",
                  "parentUUID": "e2db7113-c109-4a23-801e-f6207f18c9bf",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "66fa5cd6-67f8-45d9-98be-c4d17ea1e3fe",
                "2e06c8f4-ccd7-4904-a55c-73fa5b2e3dad",
                "5870bec0-be19-44ff-a6b5-c83efeccfe4e",
                "663864b4-76e9-4bc0-84de-dcffd0b87071",
                "e1b3bf75-e879-4ba2-a631-492c73394b22",
                "d64cdf2b-0b7b-4d20-90b7-9aaa539cf149"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 162,
              "root": false,
              "rootEmpty": false,
              "_timeout": 40000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 40000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 40000
    }
  ],
  "meta": {
    "mocha": {
      "version": "10.8.2"
    },
    "mochawesome": {
      "options": {
        "quiet": true,
        "reportFilename": "report",
        "saveHtml": true,
        "saveJson": true,
        "consoleReporter": "spec",
        "useInlineDiffs": false,
        "code": true
      },
      "version": "7.1.3"
    },
    "marge": {
      "options": {
        "reportDir": "test-report",
        "reportFilename": "report",
        "quiet": true
      },
      "version": "6.2.0"
    }
  }
}